TestCase subclass: #AnonymousClassTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMA-Reflection'!!AnonymousClassTest methodsFor: 'as yet unclassified' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!testAnon	| anonClass set |	anonClass := Class new.	anonClass superclass: Set;		setFormat: Set format.	anonClass compile:		'add: anObject			Transcript show: ''adding '', anObject printString; cr.			^ super add: anObject'.	set := Set new.	set add: 1.	self assert: set size equals: 1.	set primitiveChangeClassTo: anonClass basicNew.	set add: 2.	self assert: set size equals: 2.! !Object subclass: #DynamicAccessors	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'SMA-Reflection'!!DynamicAccessors commentStamp: 'onierstrasz 8/24/2016 18:04' prior: 0!A DynamicAccessors demos lazy compilation of methods using minimal objects.!!DynamicAccessors methodsFor: 'error-handling' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!doesNotUnderstand: aMessage 	| messageName |	messageName := aMessage selector asString.	(self class instVarNames includes: messageName)		ifTrue: [self class compile: messageName , String cr , ' ^ ' , messageName.			^ aMessage sendTo: self].	super doesNotUnderstand: aMessage! !TestCase subclass: #DynamicAccessorsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMA-Reflection'!!DynamicAccessorsTest methodsFor: 'running' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!testAccessors	self deny: (DynamicAccessors methodDict keys includes: #x).	self assert: DynamicAccessors new x equals: nil.	self assert: (DynamicAccessors methodDict keys includes: #x).! !!DynamicAccessorsTest methodsFor: 'running' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!tearDown	DynamicAccessors removeSelector: #x! !Object subclass: #HaltDemo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMA-Reflection'!!HaltDemo commentStamp: 'onierstrasz 8/24/2016 17:26' prior: 0!HaltDemo new foo.HaltDemo new bar. Only the second halts within foo.!!HaltDemo methodsFor: 'as yet unclassified' stamp: 'onierstrasz 8/24/2016 17:25'!haltIfCalledFrom: aSelector	| context |	context := thisContext.	"walk up the stack looking for a Context with this selector"	[ context sender isNil ]		whileFalse: [ context := context sender.			context selector = aSelector				ifTrue: [ Halt signal ] ]! !!HaltDemo methodsFor: 'as yet unclassified' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!bar	^ (self foo), 'bar'! !!HaltDemo methodsFor: 'as yet unclassified' stamp: 'onierstrasz 8/24/2016 17:26'!foo	self haltIfCalledFrom: #bar.	^ 'foo'! !Object subclass: #LoggingMethodWrapper	instanceVariableNames: 'invocationCount method'	classVariableNames: ''	poolDictionaries: ''	category: 'SMA-Reflection'!!LoggingMethodWrapper commentStamp: 'onierstrasz 8/24/2016 18:25' prior: 0!In this approach we replace a CompiledMethod in a mathod dictionary with a "Method Wrapper", an object that implements #run:with:in: and remembers to original compiled method instance. When the method wrapper is uninstalled, the original compiled method is restored.!!LoggingMethodWrapper methodsFor: 'private' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!methodClass: aMethodClass! !!LoggingMethodWrapper methodsFor: 'private' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!selector: aSymbol! !!LoggingMethodWrapper methodsFor: 'private' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!flushCache! !!LoggingMethodWrapper methodsFor: 'evaluation' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!run: aSelector with: anArray in: aReceiver	invocationCount := invocationCount + 1.	^ aReceiver withArgs: anArray executeMethod: method! !!LoggingMethodWrapper methodsFor: 'initialize-release' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!initializeOn: aCompiledMethod	method := aCompiledMethod.	invocationCount := 0! !!LoggingMethodWrapper methodsFor: 'accessing' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!invocationCount	^ invocationCount! !!LoggingMethodWrapper methodsFor: 'actions' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!uninstall	method methodClass methodDictionary		at: method selector		put: method! !!LoggingMethodWrapper methodsFor: 'actions' stamp: 'onierstrasz 8/24/2016 18:31'!install	method methodClass methodDictionary at: method selector put: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LoggingMethodWrapper class	instanceVariableNames: ''!!LoggingMethodWrapper class methodsFor: 'instance creation' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!on: aCompiledMethod	^ self new initializeOn: aCompiledMethod! !TestCase subclass: #LoggingMethodWrapperTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMA-Reflection'!!LoggingMethodWrapperTest methodsFor: 'running' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!testDelegation	| logger |	logger := LoggingMethodWrapper on: Integer>>#factorial.		self assert: logger invocationCount equals: 0.	5 factorial.	self assert: logger invocationCount equals: 0.		logger install.	[ 5 factorial ] ensure: [logger uninstall].	self assert: logger invocationCount equals: 6.		Integer flushCache.		10 factorial.	self assert: logger invocationCount equals: 6.	! !ProtoObject subclass: #LoggingProxy	instanceVariableNames: 'subject invocationCount'	classVariableNames: ''	poolDictionaries: ''	category: 'SMA-Reflection'!!LoggingProxy commentStamp: 'onierstrasz 8/24/2016 17:46' prior: 0!A LoggingProxy demos method wrappers using the "minimal object" technique. The class inherits from ProtoObject, so it implements almost nothing. Any message sent to itr is trapped by doesNotUnderstand:. The proxy then does its logging action and forwards the message to its subject.!!LoggingProxy methodsFor: 'initialize-release' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!initialize	invocationCount := 0.	subject := self.! !!LoggingProxy methodsFor: 'accessing' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!invocationCount	^ invocationCount! !!LoggingProxy methodsFor: 'error-handling' stamp: 'onierstrasz 8/24/2016 17:47'!doesNotUnderstand: aMessage	Transcript		show: 'performing ' , aMessage printString;		cr.	invocationCount := invocationCount + 1.	^ aMessage sendTo: subject	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LoggingProxy class	instanceVariableNames: ''!!LoggingProxy class methodsFor: 'instance creation' stamp: 'onierstrasz 8/24/2016 17:52'!for: aSubject	^ self new become: aSubject! !TestCase subclass: #LoggingProxyTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMA-Reflection'!!LoggingProxyTest methodsFor: 'running' stamp: 'onierstrasz 8/24/2016 17:51'!testDelegation	| point |	point := 1 @ 2.	"LoggingProxy new become: point."	LoggingProxy for: point.	self assert: point invocationCount equals: 0.	self assert: point + (3 @ 4) equals: 4 @ 6.	self assert: point invocationCount equals: 1! !!LoggingProxyTest methodsFor: 'running' stamp: 'onierstrasz 8/24/2016 17:59'!testSelf	| point |	point := 1 @ 2.	LoggingProxy new become: point.	self assert: point invocationCount equals: 0.	self assert: (point rectangle: 3 @ 4) area equals: 4.	"rectangle: does two self-sends"	"oops -- self sends are not intercepted"	self deny: point invocationCount = 4.	self assert: point invocationCount equals: 1! !TestCase subclass: #MethodWrapperTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMA-Reflection'!!MethodWrapperTest methodsFor: 'as yet unclassified' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!testAnswer42	| demoClass |	Object subclass: #Demo		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Demo'.	demoClass := Smalltalk at: #Demo.	self should: [demoClass new answer42] raise: MessageNotUnderstood.	demoClass methodDict at: #answer42 put: ObjectsAsMethodsExample new.	self assert: demoClass new answer42 equals: 42.	demoClass removeFromSystem ! !Object subclass: #ReflectionQueries	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMA-Reflection'!!ReflectionQueries commentStamp: 'onierstrasz 9/1/2016 13:55' prior: 0!Examples queries that exploit the Smalltalk metamodel.
	ReflectionQueries new inspectCollectionSuperSends.	ReflectionQueries new inspectOtherSuperSends.	ReflectionQueries new inspectSmalltalkSyntaxMethods.!!ReflectionQueries methodsFor: 'queries' stamp: 'onierstrasz 9/1/2016 13:31'!inspectCollectionSuperSends	((Collection withAllSubclasses flatCollect: #methodDict)  select: #sendsToSuper) inspect.! !!ReflectionQueries methodsFor: 'queries' stamp: 'onierstrasz 9/1/2016 13:34'!inspectSmalltalkSyntaxMethods	"Find and inspect all Smalltalk methods with a selection of key features"(	(((((((((SystemNavigation default allMethods select: #sendsToSuper)		select: [ :m | m comment isNotNil ]) select: [ :m | m numArgs > 0 ])		select: [ :m | m assignmentNodes isNotEmpty ]) select: [ :m | m selfMessages isNotEmpty ])		select: [ :m | (m sendNodes select: #isUnary) isNotEmpty ])		select: [ :m | (m sendNodes select: #isBinary) isNotEmpty ])		select: [ :m | (m sendNodes select: #isKeyword) isNotEmpty ])		select: [ :m | (m sendNodes select: #isCascaded) isNotEmpty ])		asSortedCollection: [ :x :y | x size < y size ]) inspect! !!ReflectionQueries methodsFor: 'queries' stamp: 'onierstrasz 9/1/2016 14:49'!inspectOtherSuperSends	"Find and inspect methods that perform a super send to a different method."	((CompiledMethod allInstances select: #sendsToSuper)		select: [ :m | 			(m sendNodes select: [ :send | send isSuperSend and: [ m selector ~= send selector ] ])				isNotEmpty ]) inspect! !TestCase subclass: #ReflectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMA-Reflection'!!ReflectionTest commentStamp: 'on 3/24/2006 16:41' prior: 0!Various demonstrations of reflective capabilities of Squeak.Examples from Marcus Denker and Stéphane Ducasse!!ReflectionTest methodsFor: 'running' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!testBecomeForward	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt1 equals: (100@100).	self assert: pt1 == pt2.	self assert: pt2 == pt3.! !!ReflectionTest methodsFor: 'running' stamp: 'OscarNierstrasz 8/23/2016 15:14:47'!testBecome	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt1 equals: (100@100).	self assert: pt1 == pt2.	self assert: pt3 equals: (0@0).! !!ReflectionTest methodsFor: 'running' stamp: 'onierstrasz 8/24/2016 15:33'!testPrimitiveChangeClassTo	| anon anObject |	anon := Class new.	"NB: an anonymous class"	anon superclass: Object.	anon setFormat: Object format.	anObject := Object new.	anObject primitiveChangeClassTo: anon new.	anon compile: 'thisIsATest ^ 2'.	self assert: anObject thisIsATest equals: 2.	self should: [ Object new thisIsATest ] raise: MessageNotUnderstood! !